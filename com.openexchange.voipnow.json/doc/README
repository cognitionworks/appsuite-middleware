So, nachdem Du jetzt Stunden herumgesucht hast, warum etwas, was eigentlich im SOAP Body auftauchen sollte, im HEADER steht, ehe Du Dich an diese Datei erinnert hast, hier unsere Erkenntnisse vom 13.06.2011:

Apache CXF hat einen obskuren Fehler, der ihn dazu bringt, MessageParts durcheinander zu werfen, wenn sie den selben part Namen haben.

	<message name="callReportIn">
		<part name="messagePart" element="import0:CallReportRequest"/>
	</message>
	<message name="callReportOut">
		<part name="messagePart" element="import0:CallReportResponse"/>
	</message>
	<message name="callReportInHeader1">
		<part name="messagePart" element="import7:userCredentials"/>
	</message>
	<message name="callReportOutHeader1">
		<part name="messagePart" element="import7:serverInfo"/>
	</message>

	...

	<operation name="CallReport">
		<soap:operation soapAction="http://4psa.com/Report/2.5.1:callReportIn" style="document"/>
		<input>
			<soap:body use="literal"/>
			<soap:header message="tns:callReportInHeader1" part="messagePart" use="literal"/>
		</input>
		<output>
			<soap:body use="literal"/>
			<soap:header message="tns:callReportOutHeader1" part="messagePart" use="literal"/>
		</output>
	</operation> 
	
Sowohl CallReportRequest, als auch die beiden Header callReportInHeader1 und callReportOutHeader1 nennen ihren MessagePart "messagePart". 
Das bringt CXF durcheinander, und es denkt jetzt, alle diese Teile gehörten in den Header. Die Lösung hier für ist, die MessageParts, die in den Header gehören umzubenennen:

	<message name="callReportIn">
		<part name="messagePart" element="import0:CallReportRequest"/>
	</message>
	<message name="callReportOut">
		<part name="messagePart" element="import0:CallReportResponse"/>
	</message>
	<message name="callReportInHeader1">
		<part name="headerPart" element="import7:userCredentials"/>
	</message>
	<message name="callReportOutHeader1">
		<part name="headerPart" element="import7:serverInfo"/>
	</message>

	...

	<operation name="CallReport">
		<soap:operation soapAction="http://4psa.com/Report/2.5.1:callReportIn" style="document"/>
		<input>
			<soap:body use="literal"/>
			<soap:header message="tns:callReportInHeader1" part="headerPart" use="literal"/>
		</input>
		<output>
			<soap:body use="literal"/>
			<soap:header message="tns:callReportOutHeader1" part="headerPart" use="literal"/>
		</output>
	</operation> 

Dazu gibt es ein Skript, das wie folgt aufgerufen wird:
ruby prepare_for_cxf.rb `find . -name "*.wsdl"`

ACHTUNG: 
Die WSDL, die man zum Generieren des Codes verwendet, muss die selbe sein, die später zur Laufzeit von CXF geladen wird. Die Änderungen müssen also auch in der von CXF geladenen WSDL stecken, denn sonst zieht CXF einfach nochmal die falschen Schlüsse. 

wsdl2java call:
 ~/Downloads/apache-cxf-2.4.0/bin/wsdl2java -d ../../src/  -exsh true -autoNameResolution -frontend jaxws21 -wsdlLocation null -client voipnowservice.wsdl 