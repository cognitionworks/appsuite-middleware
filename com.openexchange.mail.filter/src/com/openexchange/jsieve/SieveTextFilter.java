/*
 *
 *    OPEN-XCHANGE legal information
 *
 *    All intellectual property rights in the Software are protected by
 *    international copyright laws.
 *
 *
 *    In some countries OX, OX Open-Xchange, open xchange and OXtender
 *    as well as the corresponding Logos OX Open-Xchange and OX are registered
 *    trademarks of the Open-Xchange, Inc. group of companies.
 *    The use of the Logos is not covered by the GNU General Public License.
 *    Instead, you are allowed to use these Logos according to the terms and
 *    conditions of the Creative Commons License, Version 2.5, Attribution,
 *    Non-commercial, ShareAlike, and the interpretation of the term
 *    Non-commercial applicable to the aforementioned license is published
 *    on the web site http://www.open-xchange.com/EN/legal/index.html.
 *
 *    Please make sure that third-party modules and libraries are used
 *    according to their respective licenses.
 *
 *    Any modifications to this package must retain all copyright notices
 *    of the original copyright holder(s) for the original code used.
 *
 *    After any such modifications, the original and derivative code shall remain
 *    under the copyright of the copyright holder(s) and/or original author(s)per
 *    the Attribution and Assignment Agreement that can be located at
 *    http://www.open-xchange.com/EN/developer/. The contributing author shall be
 *    given Attribution for the derivative code and a license granting use.
 *
 *     Copyright (C) 2004-2006 Open-Xchange, Inc.
 *     Mail: info@open-xchange.com
 *
 *
 *     This program is free software; you can redistribute it and/or modify it
 *     under the terms of the GNU General Public License, Version 2 as published
 *     by the Free Software Foundation.
 *
 *     This program is distributed in the hope that it will be useful, but
 *     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *     or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *     for more details.
 *
 *     You should have received a copy of the GNU General Public License along
 *     with this program; if not, write to the Free Software Foundation, Inc., 59
 *     Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
package com.openexchange.jsieve;

import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.jsieve.SieveException;
import org.apache.jsieve.parser.generated.Node;
import org.apache.jsieve.parser.generated.ParseException;
import org.apache.jsieve.parser.generated.SieveParser;

import com.openexchange.jsieve.commands.Command;
import com.openexchange.jsieve.commands.RuleComment;
import com.openexchange.jsieve.commands.IfStructureCommand;
import com.openexchange.jsieve.commands.RequireCommand;
import com.openexchange.jsieve.commands.Rule;
import com.openexchange.jsieve.visitors.InternalVisitor;
import com.openexchange.jsieve.visitors.Visitor;
import com.openexchange.jsieve.visitors.Visitor.OwnType;
import com.openexchange.mailfilter.ajax.SessionWrapper.Credentials;
import com.openexchange.mailfilter.ajax.exceptions.OXMailfilterException;
import com.openexchange.mailfilter.ajax.exceptions.OXMailfilterException.Code;

/**
 * This class will be used to filter out special things which are not part of
 * the sieve RFC. Those are the rulenames and the flags. Furthermore you can get
 * the uncommented rules through this class.
 * 
 * @author d7
 * 
 */
public final class SieveTextFilter {

    public class RuleListAndNextUid {
        private final ArrayList<Rule> rulelist;
        
        private final int nextuid;

        /**
         * @param rulelist
         * @param nextuid
         */
        public RuleListAndNextUid(ArrayList<Rule> rulelist, int nextuid) {
            super();
            this.rulelist = rulelist;
            this.nextuid = nextuid;
        }

        /**
         * @return the rulelist
         */
        public final ArrayList<Rule> getRulelist() {
            return rulelist;
        }

        /**
         * @return the uid
         */
        public final int getNextuid() {
            return nextuid;
        }
        
        
    }

    private static final String COMMENT_TAG = "#<!-->";
    
    private static final String CRLF = "\r\n";

    private static final String FIRST_LINE = "# Generated by OX Sieve Bundle on ";

    // Set this value to 0 if you don't need the first comment line inside the script
    private static final int FIRST_LINE_OFFSET = 1;
    
    private static final String FLAG_TAG = "## Flag: ";
    
    private static final String LEGAL_FLAG_CHARS = "[a-zA-Z1-9]";

    private static final Log LOG = LogFactory.getLog(SieveTextFilter.class);
    
    private static final String RULENAME_TAG = "Rulename: ";
    
    private static final String SEPARATOR = "|";
    
    private static final String SEPARATOR_REGEX = "\\" + SEPARATOR;
    
    private static final String UNIQUE_ID = "UniqueId:";
    
    private static final String MATCH_STRING = "([^" + SEPARATOR_REGEX + "]*?)";
    
    private static final Pattern PATTERN = Pattern.compile("^" + FLAG_TAG + MATCH_STRING + SEPARATOR_REGEX + UNIQUE_ID + MATCH_STRING + SEPARATOR_REGEX + RULENAME_TAG + "(.*?)$");

    private final String username;
    
    public SieveTextFilter(final Credentials creds) {
        this.username = creds.getRightUsername();
    }
    
    public SieveTextFilter(final String username) {
        this.username = username;
    }
    
    @SuppressWarnings("unchecked")
    public RuleListAndNextUid readScriptFromString(final String readFileToString) throws ParseException, UnsupportedEncodingException, SieveException, OXMailfilterException {
        // The following line strips off the first line of the script
        // final String first = readFileToString.replaceAll("^.*(\r)?\n", "");
        final String commentedlines = diffremovenotcommentedlines(kickcommentsright(readFileToString), readFileToString);

        final Node uncommented = new SieveParser(new ByteArrayInputStream(readFileToString.getBytes("UTF-8"))).start();
        // final List<OwnType> jjtAccept = (List<OwnType>)
        // uncommented.jjtAccept(new Visitor(), null);
        // log.debug(jjtAccept);
        final Node commented = new SieveParser(new ByteArrayInputStream(commentedlines.getBytes("UTF-8"))).start();
        // log.debug("\n-------------------------");
        // final List<OwnType> jjtAccept2 = (List<OwnType>)
        // commented.jjtAccept(new Visitor(), null);
        // log.debug(jjtAccept2);
        final ArrayList<RuleComment> rulenames = getRulenames(readFileToString);
        final ArrayList<Rule> rules = (ArrayList<Rule>) uncommented.jjtAccept(new InternalVisitor(), Boolean.FALSE);
        final ArrayList<Rule> rules2 = (ArrayList<Rule>) commented.jjtAccept(new InternalVisitor(), Boolean.TRUE);
        // Attention after merging the manipulation of finalrules also
        // manipulates rules and rules2
        final ArrayList<Rule> finalrules = mergerules(rules, rules2);
        addRulenameToFittingCommand(rulenames, finalrules, readFileToString, commentedlines);
        final int uid = setPosAndMissingErrortextsAndIds(finalrules, readFileToString, commentedlines);
        return new RuleListAndNextUid(finalrules, uid);
    }

    /**
     * This method is used to get back the resulting sieve script
     * 
     * @param finalrules
     * @return
     * @throws SieveException
     */
    @SuppressWarnings("unchecked")
    public String writeback(final ArrayList<Rule> finalrules) throws SieveException {
        final ArrayList<Rule> finalruleswithrightrequires = addRightRequires(finalrules);
        addLines(finalruleswithrightrequires);
        final ArrayList<Rule> noncommented = new ArrayList<Rule>();
        final ArrayList<Rule> commented = new ArrayList<Rule>();
        splitRules(finalruleswithrightrequires, noncommented, commented);

        // Convert the rules to jjTree form but only if they are filled
        Node noncommentednode = null;
        final RuleConverter ruleConverter = new RuleConverter();
        if (!noncommented.isEmpty()) {
            noncommentednode = ruleConverter.rulesToNodes(noncommented);
        }
        final Node commentednode = ruleConverter.rulesToNodes(commented);

        // and convert this to a writeable form
        List<OwnType> noncommentedoutput = new ArrayList<OwnType>();
        if (null != noncommentednode) {
            noncommentedoutput = (List<OwnType>) noncommentednode.jjtAccept(new Visitor(), null);
        }
        final List<OwnType> commentedoutput = (List<OwnType>) commentednode.jjtAccept(new Visitor(), null);

        return listToString(interweaving(noncommentedoutput, commentedoutput, extractrulenames(finalrules)));
    }

    /**
     * This method goes through all Rules and adds a fitting line number
     * 
     * @param finalrules
     */
    private void addLines(ArrayList<Rule> finalrules) {
        // We add one to the first line offset here, so that the first real rule isn't written directly below
        // the require rule
        int linenumber = FIRST_LINE_OFFSET + 1;
        for (int i = 0; i < finalrules.size(); i++) {
            final Rule rule = finalrules.get(i);
            final RuleComment ruleComment = rule.getRuleComment();
            if (null != ruleComment) {
                ruleComment.setLine(linenumber++);
            }
            rule.setLinenumber(linenumber);
            // Here we add one because a space between two rules looks better
            linenumber += countcommandlines(rule.getCommands()) + 1;
        }
    }

    private void addPlainTextToRule(final String wholetext, final String commentedtext, final RuleComment ruleComment, Rule rightrule) {
        final int linenumber = rightrule.getLinenumber();
        final int endlinenumber = rightrule.getEndlinenumber();
        if (null != ruleComment) {
            final int line = ruleComment.getLine();
            final String comment = getRightPart(wholetext, line, line);
            if (rightrule.isCommented()) {
                rightrule.setText(comment + CRLF + getRightPart(commentedtext, linenumber, endlinenumber));
            } else {
                rightrule.setText(comment + CRLF + getRightPart(wholetext, linenumber, endlinenumber));
            }
        } else {
            if (rightrule.isCommented()) {
                rightrule.setText(getRightPart(commentedtext, linenumber, endlinenumber));
            } else {
                rightrule.setText(getRightPart(wholetext, linenumber, endlinenumber));
            }
        }
    }

    /**
     * This method removes require commands in a list of rules if there are any
     * and adds the proper require commands according to the actions used in the
     * command within
     * 
     * @param rules
     * @return
     */
    private ArrayList<Rule> addRightRequires(final ArrayList<Rule> rules) {
        final ArrayList<Rule> newruleslist = new ArrayList<Rule>();
        final HashSet<String> requiredlist = new HashSet<String>();
        for (final Rule rule : rules) {
            if (null == rule.getRequireCommand()) {
                newruleslist.add(rule);
                if (!rule.isCommented()) {
                    for (final Command command : rule.getCommands()) {
                        requiredlist.addAll(command.getRequired());
                    }
                }
            }
        }
        if (!requiredlist.isEmpty()) {
            final ArrayList<ArrayList<String>> arrayList = new ArrayList<ArrayList<String>>();
            arrayList.add(new ArrayList<String>(requiredlist));
            final ArrayList<Command> commandlist = new ArrayList<Command>();
            commandlist.add(new RequireCommand(arrayList));
            newruleslist.add(0, new Rule(commandlist, FIRST_LINE_OFFSET + 1));
        }
        return newruleslist;
    }

    /**
     * This method adds the rulename to the fitting command. It will also take care that only the errortext and the ruletext are left if an
     * error has occured.
     * 
     * @param ruleComments All the comments which are found and must be applied to a rule
     * @param rules The rules
     * @param wholetext The whole text of the script
     * @param commentedtext The commented text of the script
     */
    private void addRulenameToFittingCommand(ArrayList<RuleComment> ruleComments, ArrayList<Rule> rules, final String wholetext, final String commentedtext) {
        for (final RuleComment ruleComment : ruleComments) {
            int mindiff = Integer.MAX_VALUE;
            Rule rightrule = null;
            for (final Rule rule : rules) {
                final int abs = getPosDif(rule.getLinenumber() - ruleComment.getLine());
                if (abs < mindiff) {
                    mindiff = abs;
                    rightrule = rule;
                }
            }
            if (null != rightrule) {
                final String errortext = ruleComment.getErrortext();
                if (null != errortext) {
                    final String errormsg = rightrule.getErrormsg();
                    rightrule.setErrormsg(null != errormsg ? errormsg + CRLF + errortext: errortext);
                    handleRuleError(wholetext, commentedtext, ruleComment, rightrule);
                } else {
                    rightrule.setRuleComments(ruleComment);
                    handleRuleError(wholetext, commentedtext, ruleComment, rightrule);
                }
            }
        }
    }

    /**
     * This methods counts the lines which will be produced by the array of
     * commands given
     * 
     * @param commands
     * @return
     */
    private int countcommandlines(final ArrayList<Command> commands) {
        int i = 0;
        for (final Command command : commands) {
            if (command instanceof IfStructureCommand) {
                i += 2;
                final IfStructureCommand ifstructure = (IfStructureCommand) command;
                i += ifstructure.getActioncommands().size();
                i++;
            } else {
                i++;
            }
        }
        return i;
    }

    /**
     * 
     * TODO: decribe what this method does
     * 
     * @param test
     * @param first
     * @return
     */
    private String diffremovenotcommentedlines(final String test, final String first) {
        final ArrayList<String> removedcomments = stringToList(test);
        final List<String> orig = stringToList(first);
        for (int i = 0; i < orig.size(); i++) {
            final String removedcommentsline = removedcomments.get(i);
            final String origline = orig.get(i);
            if (removedcommentsline.equals(origline)) {
                removedcomments.remove(i);
                removedcomments.add(i, "");
            }
        }
        return listToString(removedcomments);
    }

    private ArrayList<RuleComment> extractrulenames(ArrayList<Rule> finalrules) {
        final ArrayList<RuleComment> retval = new ArrayList<RuleComment>();
        for (final Rule rule : finalrules) {
            final RuleComment ruleComment = rule.getRuleComment();
            if (null != ruleComment) {
                retval.add(ruleComment);
            }
        }
        return retval;
    }

    private void fillup(final List<String> retval, final int i) {
        for (int o = 0; o < i; o++) {
            retval.add("");
        }
    }

    private int getPosDif(int i) {
        return (i > 0) ? i : Integer.MAX_VALUE;
    }

    private String getRightPart(final String commentedtext, int linenumber, int endlinenumber) {
        int start = 0;
        int end = 0;
        int number = 1;
        while (number < linenumber) {
            final int indexOf = commentedtext.indexOf(CRLF, start);
            start = indexOf + CRLF.length();
            number++;
        }
        end = start;
        while (number <= endlinenumber) {
            final int indexOf = commentedtext.indexOf(CRLF, end);
            end = indexOf + CRLF.length();
            number++;
        }
        return commentedtext.substring(start, end);
    }

    private ArrayList<RuleComment> getRulenames(final String readFileToString) throws OXMailfilterException {
        final ArrayList<RuleComment> ruleComments = new ArrayList<RuleComment>();
        final ArrayList<String> stringToList = stringToList(readFileToString);
        for (int i = 0; i < stringToList.size(); i++) {
            final String line = stringToList.get(i);
            final Matcher matcher = PATTERN.matcher(line);
            if (matcher.matches()) {
                final String flags = matcher.group(1);
                if (flags.length() > 0) {
                    String errortext = null;
                    final List<String> flaglist = Arrays.asList(flags.split(","));
                    for (final String flag : flaglist) {
                        final String illegal = flag.replaceAll(LEGAL_FLAG_CHARS,"");
                        if( illegal.length() > 0 ) {
                            final String error = "Illegal chars inside flags: \""+illegal+"\"";
                            if (null != errortext) {
                                errortext += CRLF + error;
                            } else {
                                errortext = error;
                            }
                        }
                    }
                    if (null != errortext) {
                        ruleComments.add(new RuleComment(i + 1, errortext));
                    } else {
                        try {
                            final int uniqueid = Integer.parseInt(matcher.group(2));
                            ruleComments.add(new RuleComment(flaglist, uniqueid, matcher.group(3), i + 1));
                        } catch (final NumberFormatException e) {
                            ruleComments.add(new RuleComment(i + 1, "Unique id is no integer"));
                        }
                    }
                } else {
                    try {
                        final int uniqueid = Integer.parseInt(matcher.group(2));
                        ruleComments.add(new RuleComment(uniqueid, matcher.group(3), i + 1));
                    } catch (final NumberFormatException e) {
                        ruleComments.add(new RuleComment(i + 1, "Unique id is no integer"));
                    }
                }
            }
        }
        return ruleComments;
    }

    private void handleRuleError(final String wholetext, final String commentedtext, final RuleComment rulename, Rule rightrule) {
        final String errormsg = rightrule.getErrormsg();
        if (null != errormsg) {
            rightrule.setCommands(null);
            addPlainTextToRule(wholetext, commentedtext, rulename, rightrule);
            printErrorForUser(new OXMailfilterException(Code.SIEVE_ERROR, errormsg));
        }
    }

    private List<String> interweaving(List<OwnType> noncommentedoutput, List<OwnType> commentedoutput, ArrayList<RuleComment> rulenames) {
        final List<String> retval = new ArrayList<String>();
        retval.add(FIRST_LINE + (new Date()).toString());
        for (final OwnType owntype : noncommentedoutput) {
            final int linenumber = owntype.getLinenumber();
            final String string = owntype.getOutput().toString();
            final int size = retval.size();
            if (linenumber > size + 1) {
                fillup(retval, linenumber - (size + 1));
            }
            retval.addAll(stringToList(string));
        }
        for (final OwnType owntype : commentedoutput) {
            final int linenumber = owntype.getLinenumber();
            final String string = owntype.getOutput().toString();
            final int size = retval.size();
            if (linenumber > size) {
                fillup(retval, linenumber - (size));
            }
            final List<String> stringToListComment = stringToListComment(string);
            if (linenumber == retval.size()) {
                retval.addAll(stringToListComment);
            } else {
                final int removelines = removelines(retval, linenumber, stringToListComment.size());
                if (-1 != removelines) {
                    retval.addAll(removelines, stringToListComment);
                } else {
                    retval.addAll(stringToListComment);
                }
            }
        }
        for (final RuleComment rulename : rulenames) {
            final int line = rulename.getLine();
            final String rulename2 = rulename.getRulename();
            // The nth line is the n-1th position inside the array
            retval.add(line - 1, FLAG_TAG + listToCommaSeparatedString(rulename.getFlags()) + SEPARATOR + UNIQUE_ID + rulename.getUniqueid() + SEPARATOR
                    + RULENAME_TAG + ((null != rulename2) ? rulename2 : ""));
            searchEmptyLineAndRemove(retval, line - 1);
        }
        return retval;
    }

    /**
     * This method is used to remove the comments only at those places at which
     * they are used as comments not in multi line texts for example
     * 
     * @param readFileToString
     * @return
     */
    private String kickcommentsright(String readFileToString) {
        final StringBuilder sb = new StringBuilder(readFileToString);
        boolean dontparse = false;
        boolean nextchar = false;
        boolean newline = true;
        boolean comment = false;
        boolean commentremoved = false;
        for (int i = 0; i < sb.length();) {
            char c = sb.charAt(i);
            if (c == '\n') {
                newline = true;
                nextchar = false;
                comment = false;
                commentremoved = false;
                i++;
            } else if (!commentremoved && !comment && c == '"') { 
                // The comment flag is important because otherwise
                // you could struggle about '"' in comments
                dontparse = !dontparse; 
                nextchar = false;
                i++;
            } else if (!commentremoved && !comment && c == 't') {
                if ("text:".equals(sb.substring(i, i + 5))) {
                    dontparse = true;
                }
                nextchar = false;
                i++;
            } else if (!dontparse && !nextchar && newline && c == '#') {
                // Only delete chars at the beginning of a line
                if ((i == 0 || sb.charAt(i - 1) == '\n') && ((i + COMMENT_TAG.length()) <  sb.length()) &&
                        COMMENT_TAG.equals(sb.substring(i, i + COMMENT_TAG.length()))) {
                    sb.delete(i, i + COMMENT_TAG.length());
                }
                commentremoved = true;
                nextchar = true;
                newline = false;
            } else if (dontparse && c == '.') {
                if (sb.charAt(i - 1) == '\n' && sb.charAt(i + 1) == '\r') {
                    dontparse = false;
                }
                nextchar = false;
                i++;
            } else if (nextchar && c == '#') {
                comment = true;
                i++;
            } else {
                nextchar = false;
                i++;
            }
        }
        return sb.toString();
    }

    private String listToCommaSeparatedString(List<String> flags) {
        if (null != flags) {
            final StringBuilder sb = new StringBuilder();
            for (final String flag : flags) {
                sb.append(flag);
                sb.append(',');
            }
            return (0 != sb.length()) ? sb.deleteCharAt(sb.length() - 1).toString() : sb.toString();
        } else {
            return "";
        }
    }

    private String listToString(final List<String> list) {
        final StringBuilder sb = new StringBuilder();
        for (final String line : list) {
            sb.append(line);
            sb.append(CRLF);
        }
        return sb.toString();
    }

    /**
     * This method takes two lists of rules and merges them together
     * 
     * @param rules
     * @param rules2
     * @return
     */
    private ArrayList<Rule> mergerules(final ArrayList<Rule> rules, final ArrayList<Rule> rules2) {
        final ArrayList<Rule> retval = new ArrayList<Rule>();
        retval.addAll(rules);
        retval.addAll(rules2);
        Collections.sort(retval);
        return retval;
    }

    private void printErrorForUser(final OXMailfilterException mailfilterException) {
        LOG.error("Error in mailfilter rules of user " + this.username + ": " + mailfilterException.getMessage(), mailfilterException);
    }

    private int removelines(List<String> retval, int linenumber, int lines) {
        // Here we have to delete the lines after the linenumber which are
        // empty, so that no text is removed
        int deleteafter = -1;
        for (int i = linenumber - 1; i < retval.size(); i++) {
            if (retval.get(i).length() == 0) {
                deleteafter = i;
                break;
            }
        }
        // We only delete lines if we have found empty lines
        if (-1 != deleteafter) {
            for (int i = 0; i < lines; i++) {
                retval.remove(deleteafter);
            }
            return deleteafter;
        }
        return -1;
    }

    /**
     * This method interates over the given list from the given line on and
     * search for the next empty line. This line will then be removed
     * 
     * @param retval
     * @param line
     */
    private void searchEmptyLineAndRemove(List<String> retval, int line) {
        for (int i = line; i < retval.size(); i++) {
            if (retval.get(i).equals("")) {
                retval.remove(i);
                return;
            }
        }
    }

    /**
     * @param finalrules
     * @param wholetext
     * @param commentedtext
     * @return The next uid
     */
    private int setPosAndMissingErrortextsAndIds(ArrayList<Rule> finalrules, final String wholetext, final String commentedtext) {
        final List<Integer> uniqueids = new ArrayList<Integer>();
        int max = -1;
        int i = 0;
        for (int o = 0; o < finalrules.size(); o++) {
            final Rule rule = finalrules.get(o);
            if (null == rule.getRequireCommand()) {
                final RuleComment ruleComment = rule.getRuleComment();
                int uniqueid = -1;
                if (null != ruleComment && -1 != (uniqueid = ruleComment.getUniqueid())) {
                    if (uniqueid > max) {
                        max = uniqueid;
                    }
                } else {
                    uniqueids.add(o);
                }
                rule.setPosition(i++);
                if (null != rule.getErrormsg() && null == rule.getText()) {
                    handleRuleError(wholetext, commentedtext, null, rule);
                }
            }
        }
        // Now we go through all the rules which have to unique id
        for (final Integer id : uniqueids) {
            final Rule rule = finalrules.get(id);
            final RuleComment ruleComment = rule.getRuleComment();
            if (null != ruleComment) {
                ruleComment.setUniqueid(++max);
            } else {
                rule.setRuleComments(new RuleComment(++max));
            }
        }
        return ++max;
    }

    /**
     * This method splits the given list of rules into two separate lists one
     * for the commented rules and one for the uncommented
     * 
     * @param totalrules
     *                A list containing all rules
     * @param noncommented
     *                The list which will contain all non-commented rules
     *                afterwards
     * @param commented
     *                The list which will contain all commented rules afterwards
     */
    private void splitRules(final ArrayList<Rule> totalrules, ArrayList<Rule> noncommented, ArrayList<Rule> commented) {
        // First clear the two output lists
        noncommented.clear();
        commented.clear();
        for (final Rule rule : totalrules) {
            if (rule.isCommented()) {
                commented.add(rule);
            } else {
                noncommented.add(rule);
            }
        }
    }

    private ArrayList<String> stringToList(final String string) {
        return new ArrayList<String>(Arrays.asList(string.split(CRLF)));
    }

    private List<String> stringToListComment(final String string) {
        final ArrayList<String> retval = new ArrayList<String>();
        final String[] split = string.split(CRLF);
        for (String line : split) {
            retval.add(COMMENT_TAG + line);
        }
        return retval;
    }
}
