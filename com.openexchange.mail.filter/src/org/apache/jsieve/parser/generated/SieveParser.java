/* Generated By:JJTree&JavaCC: Do not edit this line. SieveParser.java */
package org.apache.jsieve.parser.generated;

import org.apache.jsieve.Argument;
import org.apache.jsieve.NumberArgument;
import org.apache.jsieve.TagArgument;
import org.apache.jsieve.parser.SieveNode;

public class SieveParser/*@bgen(jjtree)*/implements SieveParserTreeConstants, SieveParserConstants {/*@bgen(jjtree)*/
  protected JJTSieveParserState jjtree = new JJTSieveParserState();
  public void jjtreeOpenNodeScope(Node n) {
    ((SieveNode) n).setFirstToken(getToken(1));
  }

  public void jjtreeCloseNodeScope(Node n) {
    ((SieveNode) n).setLastToken(getToken(0));
  }

/******************************************
 * THE SIEVE LANGUAGE GRAMMAR STARTS HERE *
 ******************************************/

// start = commands   
  final public SimpleNode start() throws ParseException {
 /*@bgen(jjtree) start */
  ASTstart jjtn000 = new ASTstart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      commands();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOF_HASH_COMMENT:
        jj_consume_token(EOF_HASH_COMMENT);
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      jj_consume_token(0);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    {if (true) {
        return jjtn000;
    }}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) {
        throw (RuntimeException)jjte000;
    }}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) {
        throw (ParseException)jjte000;
    }}
    }
    {if (true) {
        throw (Error)jjte000;
    }}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
    throw new Error("Missing return statement in function");
  }

//   commands = *command
  final public void commands() throws ParseException {
 /*@bgen(jjtree) commands */
  ASTcommands jjtn000 = new ASTcommands(JJTCOMMANDS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
        command();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) {
        throw (RuntimeException)jjte000;
    }}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) {
        throw (ParseException)jjte000;
    }}
    }
    {if (true) {
        throw (Error)jjte000;
    }}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

//   command = identifier arguments ( ";" / block )
  final public void command() throws ParseException {
 /*@bgen(jjtree) command */
  ASTcommand jjtn000 = new ASTcommand(JJTCOMMAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token identifier = null;
    try {
      identifier = jj_consume_token(IDENTIFIER);
      arguments();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 25:
        jj_consume_token(25);
        break;
      case 26:
        block();
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.setName(identifier.image);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) {
        throw (RuntimeException)jjte000;
    }}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) {
        throw (ParseException)jjte000;
    }}
    }
    {if (true) {
        throw (Error)jjte000;
    }}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

//   block = "{" commands "}"
  final public void block() throws ParseException {
 /*@bgen(jjtree) block */
  ASTblock jjtn000 = new ASTblock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(26);
      commands();
      jj_consume_token(27);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) {
        throw (RuntimeException)jjte000;
    }}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) {
        throw (ParseException)jjte000;
    }}
     }
     {if (true) {
        throw (Error)jjte000;
    }}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }

//   arguments = *argument [test / test-list]
  final public void arguments() throws ParseException {
 /*@bgen(jjtree) arguments */
  ASTarguments jjtn000 = new ASTarguments(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TAG:
        case NUMBER:
        case QUOTED_STRING:
        case MULTI_LINE:
        case 31:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        argument();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case 28:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          test();
          break;
        case 28:
          test_list();
          break;
        default:
          jj_la1[4] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) {
        throw (RuntimeException)jjte000;
    }}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) {
        throw (ParseException)jjte000;
    }}
    }
    {if (true) {
        throw (Error)jjte000;
    }}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

//    argument = string-list / number / tag
  final public void argument() throws ParseException {
 /*@bgen(jjtree) argument */
  ASTargument jjtn000 = new ASTargument(JJTARGUMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token string_list = null, number = null, tag = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUOTED_STRING:
      case MULTI_LINE:
      case 31:
        string_list();
        break;
      case NUMBER:
        number = jj_consume_token(NUMBER);
        break;
      case TAG:
        tag = jj_consume_token(TAG);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    Argument value = null;
    if (null != number) {
        value = new NumberArgument(number);
    } else if (null != tag) {
        value = new TagArgument(tag);
    }
    jjtn000.setValue(value);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) {
        throw (RuntimeException)jjte000;
    }}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) {
        throw (ParseException)jjte000;
    }}
    }
    {if (true) {
        throw (Error)jjte000;
    }}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

//   test = identifier arguments
  final public void test() throws ParseException {
 /*@bgen(jjtree) test */
  ASTtest jjtn000 = new ASTtest(JJTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token identifier = null;
    try {
      identifier = jj_consume_token(IDENTIFIER);
      arguments();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.setName(identifier.image);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) {
        throw (RuntimeException)jjte000;
    }}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) {
        throw (ParseException)jjte000;
    }}
    }
    {if (true) {
        throw (Error)jjte000;
    }}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

//   test-list = "(" test *("," test) ")"
  final public void test_list() throws ParseException {
 /*@bgen(jjtree) test_list */
  ASTtest_list jjtn000 = new ASTtest_list(JJTTEST_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(28);
      test();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 29:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_3;
        }
        jj_consume_token(29);
        test();
      }
      jj_consume_token(30);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) {
        throw (RuntimeException)jjte000;
    }}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) {
        throw (ParseException)jjte000;
    }}
    }
    {if (true) {
        throw (Error)jjte000;
    }}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

//   string = quoted-string / multi-line
  final public void string() throws ParseException {
 /*@bgen(jjtree) string */
  ASTstring jjtn000 = new ASTstring(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token quoted_string = null, multi_line = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUOTED_STRING:
        quoted_string = jj_consume_token(QUOTED_STRING);
        break;
      case MULTI_LINE:
        multi_line = jj_consume_token(MULTI_LINE);
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    if (null != quoted_string) {
        jjtn000.setValue(quoted_string.image);
    } else if (null != multi_line) {
        jjtn000.setValue(multi_line.image);
    }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

//   string-list = "[" string *("," string) "]" / string         ;; if
//   there is only a single string, the brackets are optional
  final public void string_list() throws ParseException {
 /*@bgen(jjtree) string_list */
  ASTstring_list jjtn000 = new ASTstring_list(JJTSTRING_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 31:
        jj_consume_token(31);
        string();
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 29:
            ;
            break;
          default:
            jj_la1[9] = jj_gen;
            break label_4;
          }
          jj_consume_token(29);
          string();
        }
        jj_consume_token(32);
        break;
      case QUOTED_STRING:
      case MULTI_LINE:
        string();
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) {
        throw (RuntimeException)jjte000;
    }}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) {
        throw (ParseException)jjte000;
    }}
    }
    {if (true) {
        throw (Error)jjte000;
    }}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  public SieveParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[11];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x100,0x200,0x6000000,0x80033000,0x10000200,0x10000200,0x80033000,0x20000000,0x30000,0x20000000,0x80030000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  public SieveParser(java.io.InputStream stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new SieveParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) {
        jj_la1[i] = -1;
    }
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 11; i++) {
        jj_la1[i] = -1;
    }
  }

  public SieveParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new SieveParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) {
        jj_la1[i] = -1;
    }
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 11; i++) {
        jj_la1[i] = -1;
    }
  }

  public SieveParser(SieveParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) {
        jj_la1[i] = -1;
    }
  }

  public void ReInit(SieveParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 11; i++) {
        jj_la1[i] = -1;
    }
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) {
        token = token.next;
    } else {
        token = token.next = token_source.getNextToken();
    }
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) {
        token = token.next;
    } else {
        token = token.next = token_source.getNextToken();
    }
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) {
        t = t.next;
    } else {
        t = t.next = token_source.getNextToken();
    }
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null) {
        return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    } else {
        return (jj_ntk = jj_nt.kind);
    }
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[33];
    for (int i = 0; i < 33; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 11; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 33; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
